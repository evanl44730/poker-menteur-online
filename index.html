<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DOUGLAS</title>
    <style>
        :root { --bg: #1e1e24; --felt: #27ae60; --gold: #f1c40f; --panel: #2d3436; --red: #e74c3c; }
        body { 
            margin: 0; 
            font-family: 'Segoe UI', sans-serif; 
            background: var(--bg); 
            color: white; 
            overflow: hidden; 
            width: 100%;
            height: 100vh; 
            height: 100dvh; /* Pour mobile (safari/chrome barres d'adresse) */
            display: flex; 
            flex-direction: column; 
        }

        /* --- MODE TIMER (Beige & Sablier) --- */
        
        /* 1. Fond Beige Sable */
        body.timer-mode #game-view {
            background: radial-gradient(circle, #e8dcb5 20%, #b0a17a 90%) !important;
            box-shadow: inset 0 0 50px #5e4b35;
            border: 4px solid #8c7b50;
        }
        
        /* 2. Sablier en fond */
        .timer-watermark {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20rem;
            opacity: 0.15;
            pointer-events: none;
            z-index: 0;
            display: none;
            filter: sepia(1); /* Teinte s√©pia pour coller au beige */
        }
        
        /* Animation de rotation du sablier (retournement) */
        @keyframes hourGlassSpin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            45% { transform: translate(-50%, -50%) rotate(180deg); }
            55% { transform: translate(-50%, -50%) rotate(180deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }
        body.timer-mode .timer-watermark {
            display: block;
            animation: hourGlassSpin 7s infinite ease-in-out; /* 7s comme le timer ! */
        }
        
        /* Couleur sp√©cifique pour le texte dans ce mode (Marron fonc√©) */
        body.timer-mode .claim-text { color: #5e4b35 !important; }
        
        /* Style popup beige */
        .pop-beige #mode-title { color: #f1c40f !important; text-shadow: 0 0 20px #d35400 !important; }

        /* --- MODE BLIND (Lampe Torche) --- */
        :root {
            --cursor-x: 50vw;
            --cursor-y: 50vh;
        }

        /* 1. Applique le fond aux deux √©crans : Login et Lobby */
#screen-login, #screen-lobby {
    /* Image + Voile noir sombre (pour bien lire le texte) */
    background: linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.85)), url('assets/background.png');
    
    /* L'image s'adapte √† tout l'√©cran */
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    
    /* Fixe l'image pour √©viter qu'elle bouge sur mobile (optionnel) */
    background-attachment: fixed;
    
    color: white;
}

/* 2. Am√©lioration de la bo√Æte centrale (Effet Verre) */
/* Cela s'appliquera automatiquement √† la bo√Æte de login ET √† celle du lobby */
.login-box {
    /* Fond gris fonc√© mais transparent */
    background: rgba(45, 52, 54, 0.85) !important; 
    
    /* Le flou magique derri√®re la bo√Æte */
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px); /* Pour Safari */
    
    /* Bordure subtile pour d√©tacher du fond */
    border: 1px solid rgba(255, 255, 255, 0.15);
    
    /* Ombre port√©e pour le relief */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
    
    /* S'assure que le texte est bien centr√© et lisible */
    border-radius: 12px;
    padding: 30px;
    text-align: center;
    width: 90%;
    max-width: 400px;
}



        /* Le calque noir qui recouvre tout */
        #blind-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Laisse passer les clics */
            z-index: 900; /* Au dessus de tout sauf des modales */
            
            /* L'effet lampe torche : Un cercle transparent au milieu d'un fond noir */
            background: radial-gradient(circle 300px at var(--cursor-x) var(--cursor-y), 
                        transparent 0%, 
                        rgba(0,0,0,0.5) 30%, 
                        black 70%);
            
            display: none; /* Cach√© par d√©faut */
            transition: opacity 1s;
        }

        /* Quand le mode est activ√© via JS */
        body.blind-mode #blind-overlay {
            display: block;
        }

        /* R√àGLE D'OR : On cache VOS cartes, m√™me sous la lampe torche */
        body.blind-mode .my-hand-area img {
            filter: brightness(0) !important; /* Rend les cartes toutes noires */
            pointer-events: none;
        }
        
        /* Petit message d'ambiance */
        .blind-warning {
            position: absolute; top: 10%; left: 50%; transform: translateX(-50%);
            color: #c0392b; font-family: 'Courier New', monospace; font-weight: bold;
            font-size: 2rem; z-index: 950; display: none; text-shadow: 0 0 10px red;
            pointer-events: none;
        }
        body.blind-mode .blind-warning { display: block; animation: pulse-text 1s infinite; }
        
        @keyframes pulse-text { 50% { opacity: 0.5; } }

        @keyframes spinPage {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(10deg) scale(0.9); background: #8e44ad; } /* Violet mystique */
            100% { transform: rotate(0deg) scale(1); }
        }
        
        .revolution-anim {
            animation: spinPage 1s ease-in-out;
        }

        /* --- TH√àME R√âVOLUTION (Violet & Symbole) --- */
        
        /* 1. Changement de couleur du Tapis */
        body.revolution-active #game-view {
            /* On passe du vert au d√©grad√© Violet/Rouge chaotique */
            background: radial-gradient(circle, #8e44ad 20%, #2c3e50 90%) !important;
            box-shadow: inset 0 0 50px #000;
            border: 4px solid #f1c40f; /* Bordure dor√©e pour marquer l'√©v√©nement */
        }

        /* 2. Le Symbole G√©ant en fond */
        .revolution-watermark {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20rem; /* Tr√®s gros */
            color: rgba(255, 255, 255, 0.15); /* √Ä peine visible (filigrane) */
            pointer-events: none;
            z-index: 0; /* Tout au fond */
            display: none;
        }

        /* Animation de rotation lente du symbole */
        @keyframes slowSpin {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }

        body.revolution-active .revolution-watermark {
            display: block;
            animation: slowSpin 20s linear infinite;
        }

        /* Petit d√©tail : Les avatars changent aussi de couleur de bordure */
        body.revolution-active .avatar {
            border-color: #9b59b6 !important;
        }

        /* On garde aussi la petite animation de rotation d'avant si vous l'aviez mise */
        body.revolution-active .main-container {
             animation: spinPage 1s ease-in-out;
        }

        /* --- MODE MORT SUBITE (Double Peine) --- */
        
        /* 1. Fond Rouge Sang */
        body.double-penalty-mode #game-view {
            background: radial-gradient(circle, #7b0d0d 20%, #2c0404 90%) !important;
            box-shadow: inset 0 0 100px #000;
            border: 4px solid #c0392b; /* Bordure rouge */
        }

        /* 2. T√™te de mort en fond */
        .skull-watermark {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 25rem; /* √ânorme */
            opacity: 0.1; /* Tr√®s subtil */
            pointer-events: none;
            z-index: 0;
            display: none;
            filter: grayscale(100%);
        }
        
        /* Animation qui fait respirer la t√™te de mort */
        @keyframes skullPulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.1; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.2; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0.1; }
        }

        body.double-penalty-mode .skull-watermark {
            display: block;
            animation: skullPulse 4s infinite ease-in-out;
        }
        
        /* Petit d√©tail : changer la couleur du texte info en rouge */
        body.double-penalty-mode .claim-text {
            color: #e74c3c !important;
            text-shadow: 0 0 10px black;
        }

        /* --- MODE MATCH POINT (DANGER) --- */
        
        /* 1. L'Avatar en Danger (Battement de coeur) */
        @keyframes heartbeat {
            0% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
            50% { transform: translate(-50%, -50%) scale(1.15); box-shadow: 0 0 20px 10px rgba(231, 76, 60, 0); }
            100% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
        }

        .player.danger-mode .avatar {
            animation: heartbeat 0.8s infinite ease-in-out !important; /* Prioritaire sur les autres anims */
            border-color: #e74c3c !important; /* Rouge vif */
            background: #c0392b !important;
            color: white;
        }

        /* 2. La Vignette Rouge (Si C'EST MOI qui suis en danger) */
        #danger-vignette {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 850;
            
            /* Vignette rouge sombre sur les bords */
            box-shadow: inset 0 0 150px rgba(192, 57, 43, 0.9);
            display: none;
            mix-blend-mode: multiply; /* Assombrit l'ambiance */
        }
        
        /* Animation de la vignette (le stress monte et descend) */
        @keyframes vignettePulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }

        body.in-danger #danger-vignette {
            display: block;
            animation: vignettePulse 2s infinite;
        }
        
        /* ECRANS */
        .screen { display: none; width: 100%; height: 100%; flex-direction: column; align-items: center; justify-content: center; }
        .screen.active { display: flex; }
        
        /* LOGIN */
        .login-box { background: var(--panel); padding: 30px; border-radius: 12px; text-align: center; width: 90%; max-width: 400px; }
        input, select { padding: 12px; border-radius: 6px; border: 1px solid #444; background: #222; color: white; margin: 8px 0; width: 100%; box-sizing: border-box; font-size: 1rem; }
        button { background: var(--gold); color: #222; border: none; padding: 12px 20px; border-radius: 6px; font-weight: bold; cursor: pointer; margin-top: 15px; width: 100%; font-size: 1rem; }
        button:disabled { opacity: 0.5; }

        /* TABLE (RESPONSIVE) */
        #game-view { 
            position: relative; 
            width: 100%; 
            flex: 1; /* C'est la cl√© : il grandit pour remplir le vide */
            background: radial-gradient(circle, var(--felt) 20%, #1e8449 90%); 
            overflow: hidden; 
        }
        
        .center-area { 
            position: absolute; 
            top: 58%; /* Descendu de 45% √† 58% pour d√©gager le joueur du haut */
            left: 50%; 
            transform: translate(-50%, -50%); 
            text-align: center; 
            width: 90%; 
            pointer-events: none; 
            z-index: 5; /* S'assure que c'est au dessus du tapis mais sous les anims */
        }
        .claim-text { font-size: clamp(1.2rem, 4vw, 2rem); color: var(--gold); font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.8); margin-bottom: 10px; }
        
        /* CARTES SUR TABLE (FOND BLANC) */
        .visual-claim-cards { display: flex; justify-content: center; gap: 5px; flex-wrap: wrap; }
        .visual-claim-cards img { 
            width: clamp(40px, 10vw, 70px); 
            height: auto; 
            background: white; /* FOND BLANC FORC√â */
            border-radius: 4px; 
            box-shadow: 0 2px 6px rgba(0,0,0,0.5); 
        }
        .separator { font-size: 2rem; margin: 0 10px; color: white; }

        /* JOUEURS */
        .player { position: absolute; width: 80px; text-align: center; transition: all 0.5s ease; }
        .avatar { width: 50px; height: 50px; background: #333; border-radius: 50%; margin: 0 auto; display: flex; align-items: center; justify-content: center; font-weight:bold; border: 3px solid #555; position: relative; z-index: 2; }
        .player.active .avatar { border-color: var(--gold); box-shadow: 0 0 15px var(--gold); }
        .info-tag { background: rgba(0,0,0,0.7); padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; margin-top: 2px; display: inline-block; white-space: nowrap; }

        /* PANNEAU BAS (RESPONSIVE) */
        .bottom-panel { 
            background: var(--panel); 
            border-top: 4px solid #111; 
            z-index: 10; 
            width: 100%; 
            display: flex; 
            flex-direction: row; 
            
            /* Changement ici : Hauteur automatique mais limit√©e */
            height: auto; 
            max-height: 40vh; /* Ne jamais d√©passer 40% de l'√©cran */
            flex-shrink: 0; /* Emp√™che le panneau d'√™tre √©cras√© */
            padding-bottom: env(safe-area-inset-bottom); /* Pour iPhone X+ */
        }
        
        .my-hand-area { width: 35%; border-right: 2px solid #444; padding: 10px; display: flex; flex-direction: column; align-items: center; overflow-y: auto; }
        .hand-cards { display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; margin-top: 10px; }
        .hand-cards img { 
            width: clamp(50px, 8vw, 80px); 
            height: auto; 
            border-radius: 4px; 
            background: white; /* FOND BLANC */
            cursor: pointer; 
        }
        .hidden-hand img { transform: rotateY(180deg); } /* Dos */

        /* Optimisation pour les petits √©crans dans le panneau */
        .controls-area {
            flex-grow: 1;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            width: 100%; /* S'assure de prendre toute la largeur */
            box-sizing: border-box; /* Inclut le padding dans le calcul de largeur */
        }
        .input-group {
            background: rgba(0,0,0,0.2);
            padding: 8px;
            border-radius: 6px;
            
            /* LA CL√â DU SUCC√àS : */
            flex: 1 1 0px; /* Force les deux blocs √† avoir une largeur de base de 0 et √† grandir √©quitablement */
            display: flex;
            flex-direction: column;
            min-width: 0; /* Emp√™che le contenu de d√©former le flex */
        }
        .input-title {
            font-size: 0.8rem; 
            color: #aaa; 
            font-weight: bold;
        }

        .split-label {
            font-size: 0.8rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            color: white;
            width: 100%; /* Zone cliquable large */
        }

        /* --- ALIGNEMENT DES TITRES --- */
        /* On donne une hauteur fixe aux ent√™tes pour qu'ils s'alignent parfaitement */
        .input-title, .split-header {
            height: 25px;
            display: flex;
            align-items: center;
            font-size: 0.8rem;
            font-weight: bold;
            color: #aaa;
            margin-bottom: 5px;
        }

        .split-header label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            color: white; /* Le rendre plus visible comme un titre actif */
        }
        
        .row-selects {
            display: flex;
            gap: 5px;
            width: 100%;
        }
        
        .row-selects select {
            flex: 1; /* Chaque select prend sa part */
            width: 100%; /* Force la largeur max */
            min-width: 0;
            padding: 8px; /* Confort tactile */
        }

        .action-buttons {
            display: flex; 
            gap: 10px; 
            margin-top: auto; 
            width: 100%;
        }
        .action-buttons button { flex: 1; }
        .btn-call { background: var(--red); color: white; }

        /* MEDIA QUERY MOBILE (Portrait) */
        /* MEDIA QUERY MOBILE (Portrait) */
        @media (max-width: 768px) {
            .bottom-panel { 
                flex-direction: column; 
                height: auto; 
                max-height: 50vh; 
            }
            .center-area {
                top: 55%; /* Un peu plus haut sur mobile car le clavier peut g√™ner */
            }
            /* R√©duire un peu la taille des cartes centrales sur mobile */
            .visual-claim-cards img { width: clamp(30px, 12vw, 60px); }
            .claim-text { font-size: 1.2rem; margin-bottom: 5px; }
        }

        /* MODAL */
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; align-items: center; justify-content: center; z-index: 100; flex-direction: column; }
        .reveal-grid { display: flex; gap: 5px; flex-wrap: wrap; justify-content: center; padding: 20px; }
        .reveal-grid img { width: 60px; background: white; border-radius: 4px; }

        /* --- ANIMATIONS --- */

        /* 1. Entr√©e des cartes (Distribution) */
        @keyframes slideInUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .hand-cards img {
            /* On pr√©pare l'anim, le d√©lai sera g√©r√© en JS */
            animation: slideInUp 0.5s cubic-bezier(0.25, 1.5, 0.5, 1) both; 
        }

        /* 2. Pulsation du Joueur Actif */
        @keyframes pulse-ring {
            0% { box-shadow: 0 0 0 0 rgba(241, 196, 15, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(241, 196, 15, 0); }
            100% { box-shadow: 0 0 0 0 rgba(241, 196, 15, 0); }
        }
        
        .player.active .avatar {
            animation: pulse-ring 2s infinite;
        }

        /* 3. Apparition fluide des claims centraux */
        @keyframes popIn {
            0% { transform: scale(0); opacity: 0; }
            80% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .visual-claim-cards img, .separator {
            animation: popIn 0.4s ease-out both;
        }

        /* 4. Transition fluide du panneau Split */
        #split-inputs {
            transition: all 0.3s ease-in-out;
            overflow: hidden;
            max-height: 0; /* Cach√© par d√©faut */
            opacity: 0;
            margin-top: 0;
        }
        
        #split-inputs.visible {
            max-height: 100px; /* Assez grand pour le contenu */
            opacity: 1;
            margin-top: 5px;
        }

        /* 5. Feedback flottant (Texte d'action) */
        .feedback-bubble {
            position: absolute;
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
            background: rgba(0,0,0,0.8);
            padding: 5px 10px;
            border-radius: 8px;
            pointer-events: none;
            animation: floatUp 1.5s forwards;
            z-index: 20;
            white-space: nowrap;
        }

        @keyframes floatUp {
            0% { transform: translate(-50%, 0) scale(0.8); opacity: 0; }
            20% { transform: translate(-50%, -20px) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -60px) scale(1); opacity: 0; }
        }

        /* --- CARTES ADVERSAIRES (DOS) --- */
        .opponent-hand {
            display: flex;
            justify-content: center;
            margin-top: 5px;
            height: 45px; /* Hauteur fixe pour √©viter que √ßa saute */
        }

        .mini-card {
            width: 30px; /* Beaucoup plus petit que les cartes du milieu */
            height: 45px;
            background: white;
            border-radius: 3px;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            margin-left: -15px; /* Effet d'√©ventail (superposition) */
            transition: transform 0.2s;
        }

        /* La premi√®re carte ne doit pas √™tre d√©cal√©e */
        .mini-card:first-child {
            margin-left: 0;
        }
        
        /* Petit effet au survol pour voir combien il y en a */
        .opponent-hand:hover .mini-card {
            margin-left: -5px; /* On √©carte un peu les cartes au survol */
        }

        /* --- CHAT SYSTEM (Remplace les Logs) --- */
        /* --- CHAT SYSTEM (R√©tractable) --- */
    .chat-container {
        position: absolute;
        top: 10px; right: 10px;
        width: 220px;
        z-index: 80;
        display: flex; flex-direction: column;
        transition: all 0.3s ease; /* Animation fluide */
    }

    /* L'en-t√™te avec la fl√®che */
    .chat-header {
        background: rgba(0,0,0,0.8);
        color: white;
        padding: 5px 10px;
        border-radius: 6px 6px 0 0; /* Arrondi seulement en haut */
        cursor: pointer;
        display: flex; justify-content: space-between; align-items: center;
        border: 1px solid #555;
    }
    
    .chat-header:hover { background: rgba(50,50,50,0.9); }

    /* Le corps du chat (Messages + Input) */
    .chat-body-wrapper {
        background: rgba(0,0,0,0.5);
        border-radius: 0 0 6px 6px;
        overflow: hidden; /* Important pour l'animation */
        max-height: 200px; /* Hauteur max ouvert */
        transition: max-height 0.3s ease, opacity 0.3s ease;
        opacity: 1;
        display: flex; flex-direction: column; gap: 5px; padding: 5px;
    }

    /* --- √âTAT FERM√â --- */
    .chat-container.closed .chat-body-wrapper {
        max-height: 0; /* On r√©duit la hauteur √† 0 */
        padding: 0;    /* On enl√®ve le padding */
        opacity: 0;    /* On rend transparent */
        border: none;
    }
    
    .chat-container.closed .chat-header {
        border-radius: 6px; /* Arrondi complet quand ferm√© */
        width: 40px; /* Devient tout petit (juste l'ic√¥ne) */
        margin-left: auto; /* Aligne le bouton √† droite */
    }

    .arrow-icon { transition: transform 0.3s; font-size: 0.8rem; }
    .chat-container.closed .arrow-icon { transform: rotate(-90deg); } /* Fl√®che tourne */
    
    .chat-title { font-size: 0.8rem; font-weight:bold; }
    .chat-container.closed .chat-title { display: none; } /* Cache le titre quand ferm√© */

    /* Indicateur de nouveau message (Pastille rouge) */
    .new-msg-dot {
        width: 10px; height: 10px; background: #e74c3c;
        border-radius: 50%; display: none;
        box-shadow: 0 0 5px red;
    }
    .chat-container.closed.has-new .new-msg-dot { display: block; }

    /* RESTE DU CSS CHAT (Interne) */
    .chat-messages {
        max-height: 150px; overflow-y: auto;
        display: flex; flex-direction: column-reverse;
        pointer-events: none;
    }
    .chat-input-row { display: flex; gap: 5px; pointer-events: auto; }
    .chat-input-row input {
        margin: 0; padding: 5px; font-size: 0.8rem;
        background: rgba(0,0,0,0.8); border: 1px solid #555; color: white; flex: 1;
    }
    .chat-msg { margin-bottom: 3px; text-shadow: 1px 1px 0 #000; word-wrap: break-word; }
    .chat-author { color: var(--gold); font-weight: bold; margin-right: 5px; }

        /* --- 2. SHAKE EFFECT --- */
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .shake-screen { animation: shake 0.5s; }

        /* --- 3. EMOJIS --- */
        /* --- BARRE D'EMOTES (SCROLLABLE) --- */
    .emoji-bar {
        position: absolute; 
        left: 10px;
        /* On la centre verticalement ou on la place o√π on veut */
        top: 20vh; 
        z-index: 60;
        
        /* C'est ici que la magie op√®re */
        display: flex; 
        flex-direction: column; 
        align-items: center;
        gap: 10px;
        
        /* Hauteur fixe ou max (ajustez selon votre besoin) */
        max-height: 200px; 
        width: 60px; /* Un peu plus large que les boutons */
        
        /* Permet le scroll si √ßa d√©passe */
        overflow-y: auto; 
        overflow-x: hidden;
        
        /* Design de la barre (Fond unifi√©) */
        background: rgba(0, 0, 0, 0.4);
        padding: 10px 0; /* Espace en haut et en bas */
        border-radius: 30px; /* Forme de pilule allong√©e */
        border: 1px solid rgba(255,255,255,0.1);
        backdrop-filter: blur(2px); /* Petit effet de flou sympa */

        /* Cache la barre de scroll (Chrome/Safari/Opera) */
        -ms-overflow-style: none;  /* IE and Edge */
        scrollbar-width: none;  /* Firefox */
    }
    
    /* Cache la barre de scroll (Suite) */
    .emoji-bar::-webkit-scrollbar {
        display: none;
    }

    /* LE BOUTON ROND */
    .emoji-btn {
        width: 45px;  
        height: 45px;
        border-radius: 50%;
        background: rgba(255,255,255,0.1); /* Fond l√©ger */
        border: 2px solid transparent; /* Pr√©pare la bordure */
        flex-shrink: 0; /* Emp√™che l'√©crasement des boutons */
        
        display: flex; justify-content: center; align-items: center;
        overflow: hidden; padding: 0;
        cursor: pointer;
        transition: transform 0.2s, background 0.2s;
    }

    .emoji-btn:hover { 
        transform: scale(1.1); 
        background: rgba(255,255,255,0.3);
        border-color: var(--gold);
    }

    .emoji-btn img {
        width: 100%; height: 100%; object-fit: cover; pointer-events: none;
    }
        
        .floating-emoji {
            position: absolute;
            /* Plus de font-size ici car ce n'est plus du texte */
            width: 60px;  /* Taille de l'image flottante */
            height: 60px;
            animation: floatEmoji 2s forwards;
            z-index: 100;
            pointer-events: none;
        }

        @keyframes floatEmoji {
            0% { transform: translate(-50%, 0) scale(0); opacity: 0; }
            20% { transform: translate(-50%, -20px) scale(1.2); opacity: 1; }
            80% { transform: translate(-50%, -50px) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -80px) scale(0.5); opacity: 0; }
        }

        .header-row {
            height: 25px; /* Hauteur fixe pour alignement parfait */
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        /* Conteneur pour mettre les mains c√¥te √† c√¥te */
        .hands-row {
            display: flex;
            flex-direction: row;
            gap: 10px; /* Espace entre les deux blocs */
            width: 100%;
        }
        /* Sur mobile, on garde c√¥te √† c√¥te mais on r√©duit la taille si besoin */
        .hands-row .input-group {
            flex: 1; 
            min-width: 0; /* Emp√™che le d√©bordement flex */
            display: flex;
            flex-direction: column;
            margin: 0; /* Important pour l'alignement */
            height: 100%; /* Pour qu'ils aient la m√™me hauteur visuelle */
        }

        /* --- POPUP ANNONCE MODE --- */
        #mode-announcement {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 2000; /* Au-dessus de tout, m√™me du chat */
            pointer-events: none; /* Laisse passer les clics au travers */
            
            background: rgba(0,0,0,0.6); /* Assombrit l√©g√®rement l'√©cran */
            opacity: 0;
            transition: opacity 0.3s ease;
            backdrop-filter: blur(2px);
        }

        #mode-announcement.active {
            opacity: 1;
        }

        #mode-icon { font-size: 5rem; margin-bottom: 10px; transform: scale(0); transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        #mode-title { font-size: 3rem; font-weight: 900; color: white; text-transform: uppercase; text-shadow: 0 5px 15px rgba(0,0,0,0.8); transform: translateY(50px); opacity: 0; transition: all 0.5s ease 0.1s; text-align: center;}
        #mode-sub { font-size: 1.2rem; color: #ddd; font-style: italic; transform: translateY(20px); opacity: 0; transition: all 0.5s ease 0.2s; text-align: center;}

        /* Animation d'entr√©e quand la classe active est l√† */
        #mode-announcement.active #mode-icon { transform: scale(1); }
        #mode-announcement.active #mode-title { transform: translateY(0); opacity: 1; }
        #mode-announcement.active #mode-sub { transform: translateY(0); opacity: 1; }

        /* Couleurs sp√©cifiques dynamiques via JS */
        .pop-red #mode-title { color: #e74c3c !important; text-shadow: 0 0 20px #c0392b !important; }
        .pop-purple #mode-title { color: #9b59b6 !important; text-shadow: 0 0 20px #8e44ad !important; }

        #timer-bar {
            position: fixed;
            top: 0; left: 0;
            height: 10px; /* √âpaisseur de la barre */
            width: 0;     /* Cach√© par d√©faut */
            z-index: 3000; /* Au-dessus de tout, m√™me des popups */
            pointer-events: none;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        /* L'animation qui se lance √† chaque tour */
        .timer-anim {
            /* 7.5s pour correspondre au serveur (7s + petite marge) */
            animation: burnFuse 7.5s linear forwards; 
        }

        @keyframes burnFuse {
            0% { 
                width: 100%; 
                background: #2ecc71; /* Vert */
                box-shadow: 0 0 15px #2ecc71;
            }
            50% { 
                background: #f1c40f; /* Jaune */
                box-shadow: 0 0 15px #f1c40f;
            }
            85% {
                background: #e74c3c; /* Rouge */
                box-shadow: 0 0 20px #e74c3c;
            }
            100% { 
                width: 0%; 
                background: #c0392b; /* Rouge fonc√© */
            }
        }

    </style>
</head>
<body>

    <div id="mode-announcement">
        <div id="mode-icon">‚ö†Ô∏è</div>
        <div id="mode-title">TITRE DU MODE</div>
        <div id="mode-sub">Description courte</div>
    </div>
    <div id="timer-bar"></div>
    <div id="blind-overlay"></div>
    <div id="danger-vignette"></div>
    <div id="blind-overlay"></div>
    <div class="blind-warning">‚ö†Ô∏è PANNE DE COURANT ‚ö†Ô∏è</div>
    <div id="screen-login" class="screen active">
        <div class="login-box">
            <h1>DOUGLAS</h1>
            <input type="text" id="username" placeholder="Votre Pseudo" value="Joueur">
            <button onclick="connect()">JOUER</button>
        </div>
    </div>

    <div id="screen-lobby" class="screen">
        <div class="login-box">
            <h2>SALON</h2>
            <p id="lobby-msg">...</p>
            <button id="btn-start" disabled onclick="send({type: 'START_GAME'})">LANCER</button>
        </div>
    </div>

    <div id="screen-game" class="screen">
        <button id="btn-music" onclick="toggleMusic()" 
            style="position:absolute; top:10px; left:10px; z-index:100; background:rgba(0,0,0,0.5); width:40px; height:40px; padding:0; font-size:1.2rem; border-radius:50%;">
        üîä
    </button>
        <div id="game-view">
            <div class="revolution-watermark">‚ôªÔ∏è</div>
            <div class="skull-watermark">üíÄ</div>
            <div class="timer-watermark">‚è≥</div>
            <div id="players-container"></div>
            <div id="players-container"></div>
            <div class="center-area">
                <div id="claim-text" class="claim-text">...</div>
                <div id="visual-claim" class="visual-claim-cards"></div>
            </div>
        </div>

        <div id="ui-chat" class="chat-container closed" style="display:none;">
    <div class="chat-header" onclick="toggleChat()">
        <span class="new-msg-dot"></span> <span class="chat-title">CHAT</span>
        <span class="arrow-icon">‚ñº</span>
    </div>

    <div class="chat-body-wrapper">
        <div id="chat-history" class="chat-messages"></div>
        <div class="chat-input-row">
            <input type="text" id="chat-input" placeholder="Message..." maxlength="50" onkeydown="if(event.key==='Enter') sendChat()">
            <button onclick="sendChat()" style="width:auto; padding:5px 10px;">‚û§</button>
        </div>
    </div>
</div>
            <div class="emoji-bar" title="Faites d√©filer pour voir plus">
        <button class="emoji-btn" onclick="sendEmote('gelo')">
            <img src="assets/emotes/gelo.png" alt="gelo">
        </button>
        
        <button class="emoji-btn" onclick="sendEmote('max')">
            <img src="assets/emotes/max.png" alt="max">
        </button>
        
        <button class="emoji-btn" onclick="sendEmote('ciliem')">
            <img src="assets/emotes/ciliem.png" alt="ciliem">
        </button>
        
        <button class="emoji-btn" onclick="sendEmote('matou')">
            <img src="assets/emotes/matou.png" alt="matou">
        </button>
        
        <button class="emoji-btn" onclick="sendEmote('germinal')">
            <img src="assets/emotes/germinal.png" alt="germinal">
        </button>
    </div>

        <div class="bottom-panel">
            <div class="my-hand-area">
                <button style="padding:5px; margin:0; width:auto; font-size:0.8rem" onclick="toggleHand()">üëÅ</button>
                <div id="my-cards" class="hand-cards"></div>
            </div>

            <div id="controls" class="controls-area" style="opacity: 0.5; pointer-events: none;">
                
                <div class="hands-row">
                    
                    <div class="input-group">
                        <div class="header-row">
                            <div class="input-title">MAIN 1</div>
                        </div>

                        <div class="row-selects">
                            <select id="c1-combo" onchange="updateInputs(1,true)"></select>
                        </div>
                        <div class="row-selects" style="margin-top:5px">
                            <select id="c1-r1" style="display:none"></select>
                            <select id="c1-r2" style="display:none"></select>
                            <select id="c1-suit" style="display:none"></select>
                        </div>
                    </div>

                    <div class="input-group">
                        <div class="header-row">
                            <label class="split-label">
                                <input type="checkbox" id="check-split" onchange="toggleSplit()"> SPLIT (Double)
                            </label>
                        </div>
                        
                        <div id="split-inputs" style="display:none; width:100%;">
                            <div class="row-selects">
                                <select id="c2-combo" onchange="updateInputs(2,true)"></select>
                            </div>
                            <div class="row-selects" style="margin-top:5px">
                                <select id="c2-r1" style="display:none"></select>
                                <select id="c2-r2" style="display:none"></select>
                                <select id="c2-suit" style="display:none"></select>
                            </div>
                        </div>
                    </div>

                </div> <div class="action-buttons">
                    <button onclick="bid()">ENCH√âRIR</button>
                    <button class="btn-call" onclick="send({type: 'CALL'})">MENTEUR</button>
                </div>
            </div>
        </div>
    </div>

    <div id="modal-result" class="modal">
        <h1 id="res-title" style="margin:10px">RESULTAT</h1>
        <p id="res-desc" style="color:#ccc; margin:5px">D√©tails</p>
        <p id="res-stats" style="color:var(--gold); font-style:italic; margin-bottom:10px; font-size:0.9rem"></p>
        <div id="res-cards" class="reveal-grid"></div>
        <button onclick="closeModal()" style="width:auto; padding:10px 30px">OK</button>
    </div>

    <script>
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const SUITS = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
        const COMBOS = ['Carte', 'Paire', 'Double Paire', 'Brelan', 'Couleur', 'Suite', 'Full', 'Carr√©', 'QuinteFlush', 'QuinteFlushRoyale'];
        
        // Mapping assets
        const SUIT_NAMES = {'‚ô†': 'spades', '‚ô•': 'hearts', '‚ô¶': 'diamonds', '‚ô£': 'clubs'};
        const RANK_NAMES = {'10': '10', 'J': 'jack', 'Q': 'queen', 'K': 'king', 'A': 'ace'};

        // --- AUDIO SYSTEM ---
        // --- SYST√àME SONORE (Liens Google Actions Fiables) ---
        const SOUNDS = {
            // Un petit "pop" discret pour signaler mon tour
            turn: new Audio('assets/sounds/turn.mp3'),

            heartbeat: new Audio('assets/sounds/heart.mp3'),

            revolution : new Audio('assets/sounds/revolution.mp3'),

            blind: new Audio('assets/sounds/blind.mp3'),
            
            // Bruit de pi√®ce/jeton sur du bois pour l'ench√®re
            bid: new Audio('assets/sounds/bet.mp3'),
            
            // Bruit m√©tallique/drama pour le "Menteur"
            lie_found: new Audio('assets/sounds/liar.mp3'),

            truth_hurt: new Audio('assets/sounds/truth.mp3'),
            
            // Bruit de papier/cartes pour le m√©lange
            start: new Audio('assets/sounds/cards.mp3'),

            gelo: new Audio('assets/sounds/gelo.mp3'),
            
            // üòé : Un son "Cool" / Magique
            germinal: new Audio('assets/sounds/germinal.mp3'),
            
            // üò° : Un coup ou un grognement
            matou: new Audio('assets/sounds/matou.mp3'),
            
            // üçÖ : Un bruit d'√©crasement (Splat)
            max: new Audio('assets/sounds/max.mp3'), // (Faute de mieux en lien direct, mettez un bruit de splat localement)
            
            // ü§° : Le klaxon de clown (Honk)
            ciliem: new Audio('assets/sounds/ciliem.mp3')
        };

        const BGM = new Audio('assets/sounds/jazz.mp3');
        const WLCM = new Audio('assets/sounds/welcome.mp3');
        BGM.loop = true;   // La musique tourne en boucle
        BGM.volume = 0.2;
        
        // R√©glage du volume pour √©viter de casser les oreilles
        Object.values(SOUNDS).forEach(s => s.volume = 0.5);

        // Fonction de lecture robuste
        function playSfx(key) {
            const original = SOUNDS[key];
            if (original) {
                // cloneNode permet de superposer les sons (ex: 2 ench√®res rapides)
                const clone = original.cloneNode(true);
                clone.volume = original.volume; 
                
                // On joue et on g√®re l'erreur silencieusement si le navigateur bloque encore
                clone.play().catch(e => console.warn("Son bloqu√© (attente interaction):", key));
            }
        }

        // Fonction pour d√©bloquer l'audio au premier clic (Obligatoire sur Chrome/Mobile)
        function unlockAudioContext() {
            // 1. D√©blocage des SFX (code existant)
            Object.values(SOUNDS).forEach(sound => {
                const p = sound.play();
                if(p !== undefined) {
                    p.then(_ => { sound.pause(); sound.currentTime = 0; }).catch(e => {});
                }
            });

            // 2. Lancement de la MUSIQUE
            BGM.play().catch(e => console.log("Musique bloqu√©e en attente d'interaction"));
            WLCM.play().catch(e => console.log("Musique bloqu√©e en attente d'interaction"));
        }

        function toggleMusic() {
            const btn = document.getElementById('btn-music');
            if (BGM.paused) {
                BGM.play();
                btn.innerText = "üîä";
                btn.style.opacity = "1";
            } else {
                BGM.pause();
                btn.innerText = "üîá";
                btn.style.opacity = "0.5";
            }
        }

        

        function sendEmote(emoji) {
            send({type: 'EMOTE', content: emoji});
        }

        // Remarquez bien le deuxi√®me param√®tre : 'emoteName' (et non 'emoji')
        function showEmote(playerIdx, emoteName) {
            
            // --- 1. Calcul de la position (Code inchang√©) ---
            const count = gameState.players.length;
            const rx = 35, ry = 25;
            let left, top;

            if (playerIdx === myIdx && count > 1) { 
                left = 50; top = 80; 
            } else {
                const ang = ((playerIdx - myIdx + count) % count) * (2*Math.PI/count) + Math.PI/2;
                left = 50 + rx * Math.cos(ang);
                top = 45 + ry * Math.sin(ang);
            }

            // --- 2. Cr√©ation de l'image (C'est ici que l'erreur se produisait) ---
            const img = document.createElement('img');
            img.className = 'floating-emoji';
            
            // Gestion de l'extension (.gif pour cool, .png pour le reste)
            let ext = '.png';
            
            // Ici on utilise bien 'emoteName' qui est d√©fini dans la premi√®re ligne de la fonction
             
            // Construction du chemin
            // M√©thode sans backticks, impossible de se tromper
            console.log("Le code cherche l'image ici :", 'assets/emotes/' + emoteName + ext);
            img.src = 'assets/emotes/' + emoteName + ext;
            
            img.style.left = left + '%';
            img.style.top = top + '%';
            
            document.body.appendChild(img);
            
            // Suppression apr√®s 2 secondes
            setTimeout(() => img.remove(), 2000);
        }

        let ws, myIdx, gameState, handHidden = false;
        let lastTurnIdx = -1; // <--- AJOUTEZ CETTE VARIABLE

        // INIT SELECTS (Avec option vide pour le "vague")
        function initSelects(prefix, isSec=false) {
            const cb = document.getElementById(`${prefix}-combo`);
            const combos = isSec ? COMBOS.slice(1) : COMBOS;
            combos.forEach(c => cb.add(new Option(c, c)));
            
            const r1 = document.getElementById(`${prefix}-r1`);
            const r2 = document.getElementById(`${prefix}-r2`);
            
            // Ajout de l'option vide "-"
            [r1, r2].forEach(s => {
                s.add(new Option("-", "")); 
                RANKS.forEach(r => s.add(new Option(r, r)));
            });
            
            const su = document.getElementById(`${prefix}-suit`);
            su.add(new Option("-", ""));
            SUITS.forEach(s => su.add(new Option(s, s)));
        }
        initSelects('c1'); initSelects('c2', true);
        updateInputs(1); updateInputs(2);

        function updateInputs(n, isUserChange=false) {
            const p = `c${n}`;
            const c = document.getElementById(`${p}-combo`).value;
            const r1 = document.getElementById(`${p}-r1`);
            const r2 = document.getElementById(`${p}-r2`);
            const s = document.getElementById(`${p}-suit`);

            // --- AJOUT : R√©initialiser les valeurs si l'utilisateur change de combo ---
            // Cela √©vite de garder "10" si on passe de "Suite" √† "Quinte Flush"
            if (isUserChange) {
                r1.value = "";
                r2.value = "";
                s.value = "";
            }
            // -------------------------------------------------------------------------

            // Gestion de l'affichage des s√©lecteurs (Rank/Suit)
            r1.style.display = 'none'; r2.style.display = 'none'; s.style.display = 'none';

            if(['Carte','Paire','Brelan','Carr√©','Full','Double Paire','Suite'].includes(c)) r1.style.display = 'block';
            if(['Double Paire','Full'].includes(c)) r2.style.display = 'block';
            if(['Couleur','QuinteFlush','QuinteFlushRoyale'].includes(c)) s.style.display = 'block';

            // Si on modifie la Main 1 (n=1), on coupe la Main 2
            if (n === 1) {
                const splitCheck = document.getElementById('check-split');
                if (splitCheck.checked) {
                    splitCheck.checked = false;
                    toggleSplit(); 
                }
            }
        }

        function restartTimerAnim() {
        const bar = document.getElementById('timer-bar');
        
        // 1. On retire la classe pour stopper l'animation en cours
        bar.classList.remove('timer-anim');
        
        // 2. Astuce magique : On force le navigateur √† recalculer le style (Reflow)
        // Sans √ßa, il ne verrait pas qu'on a enlev√© puis remis la classe instantan√©ment
        void bar.offsetWidth; 
        
        // 3. On remet la classe pour red√©marrer l'animation du d√©but
        bar.classList.add('timer-anim');
    }

    function stopTimerAnim() {
        const bar = document.getElementById('timer-bar');
        bar.classList.remove('timer-anim');
        bar.style.width = '0'; // On la cache
    }

        function resetGameInputs() {
            // 1. Remettre la Main 1 sur "Carte" et vider les valeurs
            document.getElementById('c1-combo').value = 'Carte';
            document.getElementById('c1-r1').value = '';
            document.getElementById('c1-r2').value = '';
            document.getElementById('c1-suit').value = '';

            // 2. Remettre la Main 2 √† z√©ro
            document.getElementById('c2-combo').value = 'Carte'; // Ou 'Paire' selon votre config par d√©faut
            document.getElementById('c2-r1').value = '';
            document.getElementById('c2-r2').value = '';
            document.getElementById('c2-suit').value = '';

            // 3. D√©sactiver le split
            document.getElementById('check-split').checked = false;
            toggleSplit(); // Cache la div split
            
            // 4. Mettre √† jour l'affichage des inputs de la main 1 (pour cacher Suit/R2 si n√©cessaire)
            updateInputs(1);
        }

        function toggleSplit() {
            const div = document.getElementById('split-inputs');
            const checked = document.getElementById('check-split').checked;
            
            if (checked) {
                div.style.display = 'block'; // N√©cessaire pour que le DOM existe
                // Petit d√©lai pour permettre la transition CSS
                setTimeout(() => div.classList.add('visible'), 10);
            } else {
                div.classList.remove('visible');
                // On attend la fin de l'anim CSS avant de mettre display: none
                setTimeout(() => div.style.display = 'none', 300);
            }
        }

        // --- RESEAU ---
        function connect() {
            unlockAudioContext();
            const host = location.hostname || 'localhost';
            ws = new WebSocket('ws://' + host + ':5555');
            ws.onopen = () => ws.send(JSON.stringify({type: 'LOGIN', name: document.getElementById('username').value}));
            ws.onmessage = e => handle(JSON.parse(e.data));
            ws.onerror = () => alert("Impossible de se connecter au serveur WS");
        }
        function send(d) { if(ws) ws.send(JSON.stringify(d)); }

        function handle(msg) {
        if(msg.type === 'LOBBY_UPDATE') {
            document.getElementById('screen-login').classList.remove('active');
            document.getElementById('screen-lobby').classList.add('active');
            document.getElementById('lobby-msg').innerText = msg.count + " Joueurs";
            document.getElementById('btn-start').disabled = !msg.ready;
        } 
        else if(msg.type === 'STATE_UPDATE') {
            // Sauvegarde de l'ancien √©tat pour comparaison
            const oldDeclarer = gameState ? gameState.last_declarer_idx : null;
            const oldTurn = gameState ? gameState.current_player_idx : null;
            document.getElementById('ui-chat').style.display = 'flex';
            
            // Mise √† jour de l'√©tat
            gameState = msg; 
            myIdx = msg.my_idx;

            if (msg.new_round) {
                 document.body.classList.remove('revolution-active');
            }

            if (msg.new_round) {
                
                // Priorit√© 1 : Mort Subite (Double Peine)
                if (msg.is_double_penalty) {
                    triggerModePopup("MORT SUBITE", "Les d√©g√¢ts sont doubl√©s ! (x2)", "üíÄ", "pop-red");
                    playSfx('matou'); // Son dramatique
                }
                else if (msg.is_timer_mode) {
                    triggerModePopup("CHRONO", "7 secondes pour jouer !", "‚è≥", "pop-beige");
                    playSfx('bid'); // Ou un son de tic-tac si vous en avez un
                }
                // Priorit√© 2 : R√©volution
                else if (msg.effect === 'REVOLUTION') {
                    triggerModePopup("R√âVOLUTION", "Les mains ont tourn√© !", "üîÑ", "pop-purple");
                    playSfx('germinal'); // Son mystique
                }
                // Optionnel : Blind Mode (si vous voulez aussi l'annoncer en gros)
                else if (msg.is_blind) {
                    triggerModePopup("PANNE DE COURANT", "On joue √† l'aveugle...", "üî¶", "");
                    playSfx('blind');
                }
            }

            if (msg.is_timer_mode) {
                // Si c'est une nouvelle manche OU que le joueur actif a chang√©
                if (msg.new_round || msg.current_player_idx !== lastTurnIdx) {
                    restartTimerAnim();
                    lastTurnIdx = msg.current_player_idx;
                }
            } else {
                // Si on n'est pas en mode timer, on s'assure que la barre est cach√©e
                stopTimerAnim();
            }

            if (msg.is_timer_mode) {
                document.body.classList.add('timer-mode');
            } else {
                document.body.classList.remove('timer-mode');
            }

            if (msg.is_double_penalty) {
                document.body.classList.add('double-penalty-mode');
                
                // Son d'ambiance si nouvelle manche (Optionnel : r√©utiliser un son effrayant)
                if (msg.new_round) {
                    playSfx('matou'); // ou un autre son grave
                    showFeedback(myIdx, "üíÄ MORT SUBITE (+2)", "#e74c3c");
                }
            } else {
                document.body.classList.remove('double-penalty-mode');
            }

            if (msg.effect === 'REVOLUTION') {
                document.body.classList.add('revolution-active');
                
                // Petit feedback sonore et visuel imm√©diat (optionnel)
                if(msg.new_round) { // Pour ne le jouer qu'une fois au d√©but
                    playSfx('germinal'); 
                    showFeedback(myIdx, "üîÑ R√âVOLUTION !", "#9b59b6");
                }
            }
            if (msg.is_blind) {
                document.body.classList.add('blind-mode');
                
                // On joue le son UNIQUEMENT si c'est le tout d√©but de la manche
                if (msg.new_round) {
                    playSfx('blind'); // <--- AJOUTEZ ICI
                }
            } else {
                document.body.classList.remove('blind-mode');
            }

            // --- GESTION DES √âCRANS ---
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('screen-game').classList.add('active');

            // --- GESTION DES SONS ET LOGS ---

            // 1. Nouvelle manche (M√©lange)
            if (msg.new_round) {
                resetGameInputs();
                showFeedback(gameState.current_player_idx, "C'est parti !", "#f1c40f");
                playSfx('start');
            }
            
            // 2. Affichage du Log (Texte)

            // 3. Son d'ench√®re (Jeton)
            // On joue le son si le "d√©clarant" a chang√© (quelqu'un a jou√©)
            // ET que ce n'est pas une nouvelle manche
            if (gameState.last_declarer_idx !== null && gameState.last_declarer_idx !== oldDeclarer && !msg.new_round) {
                playSfx('bid');
                showFeedback(gameState.last_declarer_idx, "A ENCH√âRI", "#fff");
            }

            // 4. Son "C'est mon tour" (Ding)
            // Si c'est √† moi de jouer maintenant ET que ce n'√©tait pas √† moi juste avant
            if (myIdx === gameState.current_player_idx && oldTurn !== myIdx) {
                // Petit d√©lai pour ne pas jouer en m√™me temps que le bruit de jeton
                setTimeout(() => playSfx('turn'), 500);
            }

            render();
        } 

        else if(msg.type === 'CHAT_MSG') {
            const div = document.getElementById('chat-history');
            const line = document.createElement('div');
            line.className = 'chat-msg';
            line.innerHTML = `<span class="chat-author">${msg.author}:</span> ${msg.text.replace(/</g, "&lt;")}`;
            div.prepend(line); 
            
            // --- AJOUT : GESTION NOTIFICATION ---
            const chat = document.getElementById('ui-chat');
            // Si le chat est ferm√©, on ajoute la classe "has-new" pour afficher le point rouge
            if (chat.classList.contains('closed')) {
                chat.classList.add('has-new');
            } 
            }
        else if(msg.type === 'ERROR') {
            alert(msg.msg);
        } 
        else if(msg.type === 'SHOWDOWN') {
            // Son dramatique
            if (msg.is_truth) {
                // C'√©tait la V√âRIT√â -> Celui qui a dit "Menteur" s'est tromp√© -> Son d'√©chec
                playSfx('truth_hurt');
            } else {
                // C'√©tait un MENSONGE -> Celui qui a dit "Menteur" a eu raison -> Son de r√©ussite
                playSfx('lie_found');
            }
            
            // Effet visuel
            document.body.classList.add('shake-screen');
            setTimeout(() => document.body.classList.remove('shake-screen'), 500);
            
            showResult(msg);
        } 
        else if(msg.type === 'GAME_OVER') {
            alert("GAGNANT: " + msg.winner); location.reload();
        }
        else if(msg.type === 'EMOTE') {
            showEmote(msg.idx, msg.content);
            
            // Joue le son correspondant au mot-cl√©
            switch(msg.content) {
                case 'gelo': playSfx('gelo'); break;
                case 'max': playSfx('max'); break;
                case 'matou': playSfx('matou'); break;
                case 'germinal': playSfx('germinal'); break;
                case 'ciliem': playSfx('ciliem'); break;
            }
        }
    }


        // --- RENDU ---
        function getSrc(r, s) { 
            let rn = RANK_NAMES[r]||r, sn = SUIT_NAMES[s];
            return `assets/cards/${rn}_of_${sn}.png`;
        }

        function render() {
            // --- 1. RENDU DES JOUEURS (ADVERSAIRES) ---
            const cont = document.getElementById('players-container');
            cont.innerHTML = '';
            
            const count = gameState.players.length;
            // Rayons de l'ellipse en % de la div parente (Responsive)
            const rx = 35, ry = 25; 

            gameState.players.forEach((p, i) => {
                // On ne s'affiche pas soi-m√™me dans le cercle (sauf si on est seul pour debug)
                if(i === myIdx && count > 1) return; 

                const el = document.createElement('div');
                const isDanger = (p.quota === 6);
                let classes = 'player';
                if (i === gameState.current_player_idx) classes += ' active';
                if (isDanger) classes += ' danger-mode'; // Ajoute la classe CSS rouge
                
                el.className = classes;
                // Ajout de la classe 'active' pour l'animation de pulsation si c'est son tour
            
                // Calcul de la position en cercle (Me = toujours virtuellement en bas)
                const ang = ((i - myIdx + count) % count) * (2*Math.PI/count) + Math.PI/2;
                el.style.left = (50 + rx * Math.cos(ang)) + '%';
                el.style.top = (45 + ry * Math.sin(ang)) + '%';
                el.style.transform = 'translate(-50%, -50%)';

                if (i === myIdx) {
                    if (isDanger) document.body.classList.add('in-danger');
                    else document.body.classList.remove('in-danger');
                }
                
                // G√©n√©ration HTML des cartes adverses (Dos)
                let cardsHtml = '';
                if (p.eliminated) {
                    cardsHtml = '<div class="info-tag" style="color:#e74c3c; font-weight:bold; background:rgba(0,0,0,0.8);">üíÄ √âLIMIN√â</div>';
                } else {
                    cardsHtml = '<div class="opponent-hand">';
                    // On cr√©e une image par carte poss√©d√©e
                    for(let k=0; k < p.card_count; k++) {
                        cardsHtml += '<img src="assets/cards/back.png" class="mini-card">';
                    }
                    cardsHtml += '</div>';
                }

                // Injection du HTML complet du joueur
                el.innerHTML = `
                    <div class="avatar">
                        ${p.name.substring(0,2)}
                        ${i === gameState.last_declarer_idx ? '<span style="position:absolute; top:-15px; right:-10px; font-size:1.5rem">üì¢</span>' : ''}
                    </div>
                    <div style="font-size:0.9rem; font-weight:bold; margin-top:5px; text-shadow:0 1px 2px black; color: white;">
                        ${p.name}
                    </div>
                    ${cardsHtml}
                `;
                cont.appendChild(el);
            });

            // --- 2. RENDU DE MA MAIN ---
            const handDiv = document.getElementById('my-cards');
            handDiv.innerHTML = '';
            
            gameState.my_hand.forEach((c, index) => {
                const img = document.createElement('img');
                // Gestion du bouton "Cacher/R√©v√©ler"
                img.src = handHidden ? 'assets/cards/back.png' : getSrc(c[0], c[1]);
                
                // Animation : Les cartes arrivent une par une (0s, 0.05s, 0.10s...)
                img.style.animationDelay = `${index * 0.05}s`; 
                // Assurez-vous d'avoir ajout√© la classe .hand-cards img { animation: slideInUp ... } dans le CSS
                
                handDiv.appendChild(img);
            });

            // --- 3. RENDU DU CENTRE (CLAIM / ANNONCE) ---
            // Appelle la fonction d√©di√©e qu'on a cr√©√©e pr√©c√©demment
            renderClaim(gameState.claim);

            // --- 4. GESTION DES BOUTONS (INPUTS) ---
            const isMyTurn = (myIdx === gameState.current_player_idx);
            const controlsPanel = document.getElementById('controls');

            // On grise le panneau si ce n'est pas mon tour
            controlsPanel.style.opacity = isMyTurn ? '1' : '0.5';
            controlsPanel.style.pointerEvents = isMyTurn ? 'all' : 'none';

            // --- NOUVEAU : GESTION DU BOUTON MENTEUR ---
            const btnCall = document.querySelector('.btn-call');
            
            // Si aucune ench√®re n'est en cours (gameState.claim est null), on ne peut pas appeler Menteur
            if (!gameState.claim) {
                btnCall.disabled = true;
                btnCall.style.opacity = "0.5";
                btnCall.style.cursor = "not-allowed";
                btnCall.title = "Impossible au premier tour";
            } else {
                btnCall.disabled = false;
                btnCall.style.opacity = "1";
                btnCall.style.cursor = "pointer";
                btnCall.title = "";
            }

            const currentPlayer = gameState.players[gameState.current_player_idx];
            if (currentPlayer && currentPlayer.quota === 6 && !currentPlayer.eliminated) {
                playSfx('heartbeat'); // Petit effet sonore al√©atoire d'ambiance
            }
        }

        function sendChat() {
            const inp = document.getElementById('chat-input');
            const txt = inp.value.trim();
            if(!txt) return;
            send({type: 'CHAT', content: txt});
            inp.value = '';
            inp.focus(); // Garde le focus pour continuer √† √©crire
        }

        // --- LOGIQUE VISUELLE AVANC√âE (G√®re les infos partielles) ---
        function generateVisuals(combo, r1, r2, suit) {
            let cards = [];
            
            // Helper pour alterner les couleurs (Pique, Coeur, Tr√®fle, Carreau)
            // Utile pour la "Suite" normale pour montrer que ce n'est pas une couleur
            const getMixedSuit = (idx) => SUITS[idx % 4];
            
            const addBack = (n) => { for(let i=0; i<n; i++) cards.push({r: 'back'}); };
            const addRank = (r, n, offset=0) => { for(let i=0; i<n; i++) cards.push({r: r, s: suit || getMixedSuit(offset+i)}); };
            const addSuit = (s, n) => {
                const deco = ['A', 'K', 'Q', 'J', '10']; 
                for(let i=0; i<n; i++) cards.push({r: deco[i], s: s});
            };

            // --- LOGIQUE SP√âCIALE SUITES & QUINTES ---
            if (combo === 'Suite' || combo === 'QuinteFlush' || combo === 'QuinteFlushRoyale') {
                
                let targetSuit = suit || '‚ô†';
                
                if (combo === 'QuinteFlushRoyale') {
                    // Toujours 10, J, Q, K, A
                    ['10', 'J', 'Q', 'K', 'A'].forEach(r => cards.push({r: r, s: targetSuit}));
                } 
                else {
                    // Suite ou Quinte Flush Normale
                    if (r1) {
                        const endIdx = RANKS.indexOf(r1);
                        let indices = [];

                        // On g√©n√®re 5 cartes en remontant (ex: pour 4 -> 4, 3, 2, A, K)
                        for(let i=0; i<5; i++) {
                            let idx = endIdx - i;
                            
                            // FORMULE CIRCULAIRE : Si on descend en dessous de 0 (le 2), on repart √† la fin (As, Roi...)
                            if (idx < 0) idx = RANKS.length + idx; 
                            
                            indices.push(idx);
                        }
                        
                        // On inverse pour afficher de gauche √† droite (K, A, 2, 3, 4)
                        indices.reverse();

                        indices.forEach(idx => {
                            let r = RANKS[idx];
                            // Si QuinteFlush : M√™me couleur. Si Suite : Couleurs m√©lang√©es.
                            let s = (combo === 'QuinteFlush') ? targetSuit : getMixedSuit(idx);
                            cards.push({r: r, s: s});
                        });

                    } else {
                        // Si pas de hauteur pr√©cis√©e
                        addBack(5);
                    }
                }
                return cards;
            }

            // --- AUTRES COMBINAISONS (Logic inchang√©e) ---
            if (combo === 'Carte') r1 ? addRank(r1, 1) : addBack(1);
            else if (combo === 'Paire') r1 ? addRank(r1, 2) : addBack(2);
            else if (combo === 'Double Paire') {
                r1 ? addRank(r1, 2, 0) : addBack(2);
                r2 ? addRank(r2, 2, 2) : addBack(2);
            }
            else if (combo === 'Brelan') r1 ? addRank(r1, 3) : addBack(3);
            else if (combo === 'Full') {
                r1 ? addRank(r1, 3, 0) : addBack(3);
                r2 ? addRank(r2, 2, 3) : addBack(2);
            }
            else if (combo === 'Carr√©') r1 ? addRank(r1, 4) : addBack(4);
            else if (combo === 'Couleur') suit ? addSuit(suit, 5) : addBack(5);
            else addBack(1);

            return cards;
        }

        // --- NOUVELLE FONCTION : G√©n√®re le texte joli (Ex: "Paire de Rois") ---
        function getComboText(combo, r1, r2, suit) {
            if (!combo) return "";
            
            // Si aucune valeur n'est pr√©cis√©e (le joueur a mis "-")
            if (!r1 && !r2 && !suit) return combo + " (ind√©fini)";

            switch(combo) {
                case 'Carte': 
                    return r1 ? `Carte Haute ${r1}` : "Carte Haute";
                case 'Paire': 
                    return r1 ? `Paire de ${r1}` : "Une Paire";
                case 'Double Paire': 
                    if (r1 && r2) return `Double Paire ${r1} & ${r2}`;
                    return "Double Paire";
                case 'Brelan': 
                    return r1 ? `Brelan de ${r1}` : "Brelan";
                case 'Carr√©': 
                    return r1 ? `Carr√© de ${r1}` : "Carr√©";
                case 'Full':
                    // Ex: Full aux 9 par les 4
                    if (r1 && r2) return `Full aux ${r1} par les ${r2}`;
                    if (r1) return `Full aux ${r1}`;
                    return "Full";
                case 'Couleur': 
                    return suit ? `Couleur √† ${suit}` : "Couleur";
                case 'Suite':
                case 'QuinteFlush':
                case 'QuinteFlushRoyale':
                    return r1 ? `${combo} (au ${r1})` : combo;
                default: 
                    return combo;
            }
        }

        // --- FONCTION D'AFFICHAGE PRINCIPALE ---
        function renderClaim(c) {
            const txt = document.getElementById('claim-text');
            const div = document.getElementById('visual-claim');
            div.innerHTML = '';
            
            if(!c) { 
                txt.innerText = "MANCHE " + (gameState.round || 1); 
                return; 
            }
            
            // 1. G√âN√âRATION DU TEXTE (MODIFI√â ICI)
            let mainText = getComboText(c.combo, c.rank1, c.rank2, c.suit);
            
            // Si il y a une deuxi√®me main (Split)
            if (c.sec_combo) {
                const secText = getComboText(c.sec_combo, c.sec_rank1, c.sec_rank2, c.sec_suit);
                mainText += " + " + secText;
            }
            
            txt.innerText = mainText; // On applique le texte format√©

            // 2. G√©n√©ration des cartes visuelles (Reste identique √† la version pr√©c√©dente)
            const drawList = (list) => {
                list.forEach(card => {
                    const img = document.createElement('img');
                    if(card.r === 'back') {
                        img.src = 'assets/cards/back.png';
                    } else {
                        img.src = getSrc(card.r, card.s);
                    }
                    div.appendChild(img);
                });
            };

            // Main 1 Visuelle
            const cards1 = generateVisuals(c.combo, c.rank1, c.rank2, c.suit);
            drawList(cards1);

            // Main 2 Visuelle (Split)
            if(c.sec_combo) {
                const sep = document.createElement('div'); 
                sep.className = 'separator'; 
                sep.innerText = '+';
                div.appendChild(sep);
                
                const cards2 = generateVisuals(c.sec_combo, c.sec_rank1, c.sec_rank2, c.sec_suit);
                drawList(cards2);
            }
        }

        function bid() {
            const getVal = (id) => document.getElementById(id).value;
            let d = {
                combo: getVal('c1-combo'), rank1: getVal('c1-r1'), rank2: getVal('c1-r2'), suit: getVal('c1-suit')
            };
            if(document.getElementById('check-split').checked) {
                d.sec_combo = getVal('c2-combo'); d.sec_rank1 = getVal('c2-r1'); 
                d.sec_rank2 = getVal('c2-r2'); d.sec_suit = getVal('c2-suit');
            }
            send({type: 'BID', claim: d});
        }

        function showFeedback(playerIdx, text, color) {
            const container = document.getElementById('players-container');
            // On r√©cup√®re l'√©l√©ment du joueur cible (attention √† l'indexage visuel)
            // Note: C'est un peu approximatif car on recr√©e le DOM √† chaque render.
            // On va plut√¥t utiliser les coordonn√©es calcul√©es.
            
            const count = gameState.players.length;
            const rx = 35, ry = 25; // M√™mes valeurs que dans render()
            
            const ang = ((playerIdx - myIdx + count) % count) * (2*Math.PI/count) + Math.PI/2;
            
            // Si c'est moi (et qu'on est plusieurs), je suis en bas au centre (pas dans le cercle)
            // Sauf logique responsive mobile. Pour simplifier, on recalcule la position :
            
            let left, top;
            if (playerIdx === myIdx && count > 1) {
                // Position approximative de "Ma main"
                left = 50; top = 80; 
            } else {
                left = 50 + rx * Math.cos(ang);
                top = 45 + ry * Math.sin(ang);
            }

            const bubble = document.createElement('div');
            bubble.className = 'feedback-bubble';
            bubble.innerText = text;
            bubble.style.left = left + '%';
            bubble.style.top = top + '%';
            if (color) bubble.style.color = color;
            
            document.body.appendChild(bubble); // On ajoute au body pour √™tre au dessus de tout
            
            // Nettoyage automatique apr√®s l'animation
            setTimeout(() => bubble.remove(), 1500);
        }

        function toggleHand() { handHidden = !handHidden; render(); }
        function showResult(msg) {
            const m = document.getElementById('modal-result');
            m.style.display = 'flex';
            document.getElementById('res-title').innerText = msg.title;
            document.getElementById('res-desc').innerText = msg.detail;
            
            const grid = document.getElementById('res-cards');
            const statsEl = document.getElementById('res-stats');
            if (msg.stats && msg.stats.length > 0) {
                statsEl.innerText = msg.stats[0]; // Affiche "Il y avait X cartes..."
            } else {
                statsEl.innerText = "";
            }
            grid.innerHTML = '';

            // --- TRIAGE DES CARTES ---
            const cards = msg.all_cards; // Format: [['A', '‚ô†'], ['10', '‚ô•']...]
            
            // Ordre des valeurs pour le tri (2 est petit, A est grand)
            const ranksOrder = {'2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, '10':10, 'J':11, 'Q':12, 'K':13, 'A':14};
            // Ordre arbitraire des couleurs pour grouper proprement
            const suitsOrder = {'‚ô†':1, '‚ô•':2, '‚ô£':3, '‚ô¶':4};

            // On d√©tecte le type de tri n√©cessaire selon l'annonce en cours
            const claim = gameState.claim || {};
            const isSuitBased = ['Couleur', 'QuinteFlush', 'QuinteFlushRoyale'].includes(claim.combo);
            const isStraight = ['Suite'].includes(claim.combo);

            cards.sort((a, b) => {
                const rA = ranksOrder[a[0]];
                const rB = ranksOrder[b[0]];
                const sA = suitsOrder[a[1]];
                const sB = suitsOrder[b[1]];

                if (isSuitBased) {
                    // 1. Trier par COULEUR
                    if (sA !== sB) return sA - sB;
                    // 2. Puis par RANG (Descendant : As en premier)
                    return rB - rA;
                } else {
                    // Cas Standard (Paires, Full, Suite...)
                    // 1. Trier par RANG (Descendant)
                    if (rA !== rB) return rB - rA;
                    // 2. Puis par COULEUR
                    return sA - sB;
                }
            });
            // -------------------------

            // Affichage
            cards.forEach(c => {
                let img = document.createElement('img');
                img.src = getSrc(c[0], c[1]);
                // Petite animation d'entr√©e pour le style
                img.style.animation = "popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) both";
                grid.appendChild(img);
            });
        }
        function closeModal() { document.getElementById('modal-result').style.display='none'; }

        function toggleChat() {
            const chat = document.getElementById('ui-chat');
            chat.classList.toggle('closed');
            
            // Si on ouvre, on enl√®ve la notification de nouveau message
            if (!chat.classList.contains('closed')) {
                chat.classList.remove('has-new');
            }
        }

        // --- GESTION DES RACCOURCIS CLAVIER (EMOTES) ---
        // --- GESTION DES RACCOURCIS CLAVIER ---
        document.addEventListener('keydown', (e) => {
            // S√©curit√© : On ne d√©clenche rien si l'utilisateur √©crit dans le chat ou un input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

            switch(e.key) {
                // --- AJOUT ICI : Espace ou H pour cacher/montrer ses cartes ---
                case ' ':  // Barre d'Espace
                case 's':  // Touche S
                case 'S':
                    e.preventDefault(); // Emp√™che le scroll de la page avec Espace
                    toggleHand(); 
                    break;
                // -------------------------------------------------------------

                case '1': case '&': 
                    sendEmote('gelo'); 
                    break;
                case '2': case '√©': 
                    sendEmote('max'); 
                    break;
                case '3': case '"': 
                    sendEmote('ciliem'); 
                    break;
                case '4': case "'": 
                    sendEmote('matou'); 
                    break;
                case '5': case '(': 
                    sendEmote('germinal'); 
                    break;
            }
        });

        function moveTorch(x, y) {
            document.documentElement.style.setProperty('--cursor-x', x + 'px');
            document.documentElement.style.setProperty('--cursor-y', y + 'px');
        }

        document.addEventListener('mousemove', e => moveTorch(e.clientX, e.clientY));
        document.addEventListener('touchmove', e => {
            moveTorch(e.touches[0].clientX, e.touches[0].clientY);
        });

        function triggerModePopup(title, sub, icon, colorClass) {
            const container = document.getElementById('mode-announcement');
            const elTitle = document.getElementById('mode-title');
            const elSub = document.getElementById('mode-sub');
            const elIcon = document.getElementById('mode-icon');
            
            // 1. Mise √† jour du contenu
            elTitle.innerText = title;
            elSub.innerText = sub;
            elIcon.innerText = icon;
            
            // 2. Gestion des couleurs (reset puis ajout)
            container.className = ''; 
            if (colorClass) container.classList.add(colorClass);
            
            // 3. Affichage
            container.classList.add('active');
            
            // 4. Masquage automatique apr√®s 2.5 secondes
            setTimeout(() => {
                container.classList.remove('active');
            }, 2500);
        }

    </script>
</body>
</html>
